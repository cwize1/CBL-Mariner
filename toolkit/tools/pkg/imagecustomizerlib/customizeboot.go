// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package imagecustomizerlib

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/microsoft/azurelinux/toolkit/tools/imagecustomizerapi"
	"github.com/microsoft/azurelinux/toolkit/tools/imagegen/installutils"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/file"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/grub"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/logger"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/safechroot"
	"github.com/microsoft/azurelinux/toolkit/tools/internal/shell"
)

var (
	// Regexes for finding information in the linux kernel-command line args in the grub.cfg file.
	// Note: These regexes assume that the grub.cfg file was generated by either the imager tool or the image customizer
	// tool. If the user manually modified the grub.cfg file, then they might not work correctly.
	linuxCommandLineInsertRegex = regexp.MustCompile(`(?m)^[\t ]*linux \$bootprefix/\$mariner_linux `)

	// Finds the SELinux mode line in the /etc/selinux/config file.
	selinuxConfigModeRegex = regexp.MustCompile(`(?m)^SELINUX=(\w+)$`)
)

const (
	// The index of the SELinux mode value.
	selinuxConfigModeRegexSELinuxMode = 1
)

func findSingularGrubCommand(inputGrubCfgContent string, commandName string) ([]grub.Token, error) {
	grubTokens, err := grub.TokenizeGrubConfig(inputGrubCfgContent)
	if err != nil {
		return nil, err
	}

	grubLines := grub.SplitTokensIntoLines(grubTokens)
	lines := grub.FindCommandAll(grubLines, "search")
	if len(lines) < 1 {
		return nil, fmt.Errorf("failed to find the '%s' command in grub config", commandName)
	}
	if len(lines) > 1 {
		return nil, fmt.Errorf("more than one '%s' command in grub config", commandName)
	}

	line := lines[0]
	return line, nil
}

func replaceSearchCommand(inputGrubCfgContent string, searchCommand string) (outputGrubCfgContent string, err error) {
	searchLine, err := findSingularGrubCommand(inputGrubCfgContent, "search")
	if err != nil {
		return "", err
	}

	start := searchLine[0].Loc.Start.Index
	end := searchLine[len(searchLine)-1].Loc.Start.Index
	outputGrubCfgContent = inputGrubCfgContent[:start] + searchCommand + inputGrubCfgContent[end:]

	return outputGrubCfgContent, nil
}

func replaceToken(inputGrubCfgContent string, oldToken string, newToken string) (outputGrubCfgContent string, err error) {

	// escape special characters that would interfer with defining the regular
	// expression correctly.
	tokenRegexpString := regexp.QuoteMeta(oldToken)

	// ensure the string is preceeded with separator (\t or a ' ') and create
	// a group.
	tokenRegexpString = "(?m)[\\t ](" + tokenRegexpString + ")[\\t ]"

	// create the regular expression
	tokenReplacementPath, err := regexp.Compile(tokenRegexpString)
	if err != nil {
		return "", fmt.Errorf("failed to compile regular expression (%s)", tokenRegexpString)
	}

	match := tokenReplacementPath.FindStringSubmatchIndex(inputGrubCfgContent)
	if match == nil {
		return inputGrubCfgContent, nil
	}
	for i := 2; i+1 < len(match); i = i + 2 {
		start := match[i]
		end := match[i+1]

		outputGrubCfgContent = inputGrubCfgContent[:start] + newToken + inputGrubCfgContent[end:]
	}
	return outputGrubCfgContent, nil
}

func findLinuxLine(inputGrubCfgContent string) ([]grub.Token, error) {
	linuxLine, err := findSingularGrubCommand(inputGrubCfgContent, "linux")
	if err != nil {
		return nil, err
	}

	if len(linuxLine) < 2 {
		return nil, fmt.Errorf("grub config 'linux' command is missing file path arg")
	}

	return linuxLine, nil
}

func setLinuxPath(inputGrubCfgContent string, linuxPath string) (outputGrubCfgContent string, oldKernelPath string, err error) {
	linuxLine, err := findLinuxLine(inputGrubCfgContent)
	if err != nil {
		return "", "", err
	}

	linuxFilePathToken := linuxLine[1]
	start := linuxFilePathToken.Loc.Start.Index
	end := linuxFilePathToken.Loc.End.Index

	oldKernelPath = inputGrubCfgContent[start:end]
	outputGrubCfgContent = inputGrubCfgContent[:start] + linuxPath + inputGrubCfgContent[end:]

	return outputGrubCfgContent, oldKernelPath, nil
}

func setInitrdPath(inputGrubCfgContent string, initrdPath string) (outputGrubCfgContent string, oldInitrdPath string, err error) {
	linuxLine, err := findSingularGrubCommand(inputGrubCfgContent, "initrd")
	if err != nil {
		return "", "", err
	}

	if len(linuxLine) < 2 {
		return "", "", fmt.Errorf("grub config 'initrd' command is missing file path arg")
	}

	initrdFilePathToken := linuxLine[1]
	start := initrdFilePathToken.Loc.Start.Index
	end := initrdFilePathToken.Loc.End.Index

	oldInitrdPath = inputGrubCfgContent[start:end]
	outputGrubCfgContent = inputGrubCfgContent[:start] + initrdPath + inputGrubCfgContent[end:]

	return outputGrubCfgContent, oldInitrdPath, nil
}

func appendKernelCommandLineArguments(inputGrubCfgContent string, extraCommandLine string) (outputGrubCfgContent string, err error) {
	linuxLine, err := findSingularGrubCommand(inputGrubCfgContent, "linux")
	if err != nil {
		return "", err
	}

	// Insert args at the end of the line.
	insertPoint := linuxLine[len(linuxLine)-1].Loc.End.Index
	outputGrubCfgContent = inputGrubCfgContent[:insertPoint] + " " + extraCommandLine + inputGrubCfgContent[insertPoint:]
	return outputGrubCfgContent, nil
}

type grubConfigLinuxArg struct {
	Token grub.Token
	Name  string
	Value string
}

func getLinuxCommandLineArgs(grub2Config string) ([]grubConfigLinuxArg, error) {
	linuxLine, err := findLinuxLine(grub2Config)
	if err != nil {
		return nil, err
	}

	args := []grubConfigLinuxArg(nil)
	argTokens := linuxLine[2:]

tokensLoop:
	for _, argToken := range argTokens {
		if argToken.Type != grub.WORD {
			return nil, fmt.Errorf("unexpected token (%s) in grub config linux command", grub.TokenTypeString(argToken.Type))
		}

		argStringBuilder := strings.Builder{}
		for _, subword := range argToken.SubWords {
			switch subword.Type {
			case grub.KEYWORD_STRING, grub.STRING:
				argStringBuilder.WriteString(subword.Value)

			case grub.QUOTED_VAR_EXPANSION, grub.VAR_EXPANSION:
				// Ignore words with variable expansions (e.g. $a), since there isn't any sensible way to handle them.
				continue tokensLoop
			}
		}

		argString := argStringBuilder.String()
		name, value, _ := strings.Cut(argString, "=")
		arg := grubConfigLinuxArg{
			Token: argToken,
			Name:  name,
			Value: value,
		}
		args = append(args, arg)
	}

	return args, nil
}

// Tries to find the specified kernel CLI arg. Does not fail if the arg is not found.
//
// Returns:
// - startIndex: The string index where the arg was found. Or -1 if not found.
// - endIndex: The string index of the end of the arg. Or -1 if not found.
// - value: The value of the arg. Or "" if not found.
func findKernelCommandLineArgumentArg(grub2Config string, name string) (int, int, string, error) {
	const (
		argGroupIndex      = 2
		argGroupStartIndex = argGroupIndex*2 + 0
		argGroupEndIndex   = argGroupIndex*2 + 1

		argValueGroupIndex      = 4
		argValueGroupStartIndex = argValueGroupIndex*2 + 0
		argValueGroupEndIndex   = argValueGroupIndex*2 + 1
	)

	escapedName := regexp.QuoteMeta(name)

	// "linux ... <name>=<value> ..."
	argumentRegexString := "(?m)[\\t ]+linux[\\t ](.*[\\t ])?(" + escapedName + "(=(\\S*)?)?)[\\t ]"
	argumentRegex, err := regexp.Compile(argumentRegexString)
	if err != nil {
		return 0, 0, "", fmt.Errorf("failed to compile regular expression to find (%s) kernel arg:\n%w", name, err)
	}

	match := argumentRegex.FindStringSubmatchIndex(grub2Config)
	if match == nil {
		// Arg not found.
		return -1, -1, "", nil
	}

	argValue := ""
	if len(match) > argValueGroupEndIndex {
		argValueStartIndex := match[argValueGroupStartIndex]
		argValueEndIndex := match[argValueGroupEndIndex]
		argValue = grub2Config[argValueStartIndex:argValueEndIndex]
	}

	argStartIndex := match[argGroupStartIndex]
	argEndIndex := match[argGroupEndIndex]

	return argStartIndex, argEndIndex, argValue, nil
}

func replaceKernelCommandLineArgumentValue(inputGrubCfgContent string, name string, value string,
) (outputGrubCfgContent string, oldValue string, err error) {
	// Search for the arg.
	start, end, oldValue, err := findKernelCommandLineArgumentArg(inputGrubCfgContent, name)
	if err != nil {
		return "", "", err
	}

	if start == -1 {
		return "", "", fmt.Errorf("failed to find kernel arg value for (%s)", name)
	}

	outputGrubCfgContent = fmt.Sprintf("%s%s=%s%s", inputGrubCfgContent[:start], name, value, inputGrubCfgContent[end:])

	return outputGrubCfgContent, oldValue, nil
}

// Tries to remove the specified kernel CLI arg from the grub file. Does not fail if the arg is not present.
//
// Returns:
// - outputGrubCfgContent: The resulting grub.cfg file.
// - index: The index in the grub.cfg where the arg was removed from. Or -1 if not found.
func tryRemoveKernelCommandLineArgumentValue(inputGrubCfgContent string, name string) (string, int, error) {
	// Search for the kernel CLI arg.
	start, end, _, err := findKernelCommandLineArgumentArg(inputGrubCfgContent, name)
	if err != nil {
		return "", 0, err
	}

	if start == -1 {
		// Arg not found.
		return inputGrubCfgContent, -1, nil
	}

	// Remove the arg.
	outputGrubCfgContent := inputGrubCfgContent[:start] + inputGrubCfgContent[end:]
	return outputGrubCfgContent, start, nil
}

func addKernelCommandLine(kernelExtraArguments imagecustomizerapi.KernelExtraArguments,
	imageChroot *safechroot.Chroot,
) error {
	var err error

	extraCommandLine := strings.TrimSpace(string(kernelExtraArguments))
	if extraCommandLine == "" {
		// Nothing to do.
		return nil
	}

	logger.Log.Infof("Setting KernelCommandLine.ExtraCommandLine")

	grub2ConfigFile, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	newGrub2ConfigFile, err := appendKernelCommandLineArguments(grub2ConfigFile, extraCommandLine)
	if err != nil {
		return err
	}

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2ConfigFile, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

// Updates the kernel command-line args with the new SELinux mode.
//
// See, installutils.setGrubCfgSELinux()
func updateSELinuxCommandLine(selinuxMode imagecustomizerapi.SELinuxMode, imageChroot *safechroot.Chroot) error {
	logger.Log.Infof("Updating SELinux kernel command-line args")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return err
	}

	newGrub2Config, err := updateSELinuxCommandLineHelper(grub2Config, selinuxMode)
	if err != nil {
		return err
	}

	// Update grub.cfg file.
	err = writeGrub2ConfigFile(newGrub2Config, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

func updateSELinuxCommandLineHelper(grub2Config string, selinuxMode imagecustomizerapi.SELinuxMode) (string, error) {
	// Remove all the existing SELinux args.
	grub2Config, securityIndex, err := tryRemoveKernelCommandLineArgumentValue(grub2Config, "security")
	if err != nil {
		return "", err
	}

	grub2Config, selinuxIndex, err := tryRemoveKernelCommandLineArgumentValue(grub2Config, "selinux")
	if err != nil {
		return "", err
	}

	grub2Config, enforcingIndex, err := tryRemoveKernelCommandLineArgumentValue(grub2Config, "enforcing")
	if err != nil {
		return "", err
	}

	if selinuxMode == imagecustomizerapi.SELinuxModeDisabled {
		// Don't need to insert any new args.
		return grub2Config, nil
	}

	// Find a location to add the new SELinux args.
	insertIndex := -1
	if insertIndex == -1 {
		insertIndex = enforcingIndex
	}

	if insertIndex == -1 {
		insertIndex = selinuxIndex
	}

	if insertIndex == -1 {
		insertIndex = securityIndex
	}

	if insertIndex == -1 {
		insertLocationMatch := linuxCommandLineInsertRegex.FindStringIndex(grub2Config)
		if insertLocationMatch == nil {
			return "", fmt.Errorf("failed to find location to insert SELinux kernel command-line args")
		}

		// Use the end of the regex match as the point to do the insert at.
		insertIndex = insertLocationMatch[1]
	}

	newSELinuxArgs := ""
	switch selinuxMode {
	case imagecustomizerapi.SELinuxModeForceEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxForceEnforcing

	case imagecustomizerapi.SELinuxModePermissive, imagecustomizerapi.SELinuxModeEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxSettings

	default:
		return "", fmt.Errorf("unknown SELinux mode (%s)", selinuxMode)
	}

	// Insert/replace/delete SELinux command-line arguments.
	grub2Config = fmt.Sprintf("%s %s %s", grub2Config[:insertIndex], newSELinuxArgs, grub2Config[insertIndex:])
	return grub2Config, nil
}

func getCurrentSELinuxMode(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinuxMode, error) {
	logger.Log.Debugf("Get existing SELinux mode")

	grub2Config, err := readGrub2ConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	// Try to find any existing SELinux args.
	_, _, securityValue, err := findKernelCommandLineArgumentArg(grub2Config, "security")
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	_, _, selinuxValue, err := findKernelCommandLineArgumentArg(grub2Config, "selinux")
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	_, _, enforcingValue, err := findKernelCommandLineArgumentArg(grub2Config, "enforcing")
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	// Check if SELinux is disabled.
	if securityValue != "selinux" || selinuxValue != "1" {
		return imagecustomizerapi.SELinuxModeDisabled, nil
	}

	// Check if SELinux is in forced enforcing mode.
	if enforcingValue == "1" {
		return imagecustomizerapi.SELinuxModeForceEnforcing, nil
	}

	selinuxMode, err := getSELinuxModeFromConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, err
	}

	return selinuxMode, nil
}

func getSELinuxModeFromConfigFile(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinuxMode, error) {
	selinuxConfigFilePath := filepath.Join(imageChroot.RootDir(), installutils.SELinuxConfigFile)

	// Read the SELinux config file.
	selinuxConfig, err := file.Read(selinuxConfigFilePath)
	if err != nil {
		return imagecustomizerapi.SELinuxModeDefault, fmt.Errorf("failed to read SELinux config file (%s):\n%w",
			installutils.SELinuxConfigFile, err)
	}

	match := selinuxConfigModeRegex.FindStringSubmatch(selinuxConfig)
	if match == nil {
		return imagecustomizerapi.SELinuxModeDefault, fmt.Errorf("failed to find SELinux mode in (%s) file",
			installutils.SELinuxConfigFile)
	}

	selinuxConfigMode := match[selinuxConfigModeRegexSELinuxMode]

	switch selinuxConfigMode {
	case installutils.SELinuxConfigEnforcing:
		return imagecustomizerapi.SELinuxModeEnforcing, nil

	case installutils.SELinuxConfigPermissive:
		return imagecustomizerapi.SELinuxModePermissive, nil

	case installutils.SELinuxConfigDisabled:
		return imagecustomizerapi.SELinuxModeDisabled, nil

	default:
		return imagecustomizerapi.SELinuxModeDefault, fmt.Errorf("unknown SELinux mode (%s) found in (%s) file",
			selinuxConfigMode, installutils.SELinuxConfigFile)
	}
}

func readGrub2ConfigFile(imageChroot *safechroot.Chroot) (string, error) {
	logger.Log.Debugf("Reading grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Read the existing grub.cfg file.
	grub2Config, err := file.Read(grub2ConfigFilePath)
	if err != nil {
		return "", fmt.Errorf("failed to read existing grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return grub2Config, nil
}

func writeGrub2ConfigFile(grub2Config string, imageChroot *safechroot.Chroot) error {
	logger.Log.Debugf("Writing grub.cfg file")

	grub2ConfigFilePath := getGrub2ConfigFilePath(imageChroot)

	// Update grub.cfg file.
	err := os.WriteFile(grub2ConfigFilePath, []byte(grub2Config), 0)
	if err != nil {
		return fmt.Errorf("failed to write new grub2 config file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	return nil
}

func getGrub2ConfigFilePath(imageChroot *safechroot.Chroot) string {
	return filepath.Join(imageChroot.RootDir(), installutils.GrubCfgFile)
}

func regenerateInitrd(imageChroot *safechroot.Chroot) error {
	err := imageChroot.Run(func() error {
		return shell.ExecuteLiveWithErr(1, "mkinitrd")
	})
	if err != nil {
		return fmt.Errorf("failed to rebuild initramfs file:\n%w", err)
	}

	return nil
}
