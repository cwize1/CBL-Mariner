// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package imagecustomizerlib

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"syscall"

	"github.com/microsoft/CBL-Mariner/toolkit/tools/imagecustomizerapi"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/imagegen/installutils"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/file"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/logger"
	"github.com/microsoft/CBL-Mariner/toolkit/tools/internal/safechroot"
)

var (
	// Regexes for finding information in the linux kernel-command line args in the grub.cfg file.
	// Note: These regexes assume that the grub.cfg file was generated by either the imager tool or the image customizer
	// tool. If the user manually modified the grub.cfg file, then they might not work correctly.
	extraCommandLineInsertGrubCfgRegex = regexp.MustCompile(`\tlinux .* (\$kernelopts)`)
	extraCommandLineInsertGrubRegex    = regexp.MustCompile(`GRUB_CMDLINE_LINUX_DEFAULT=".* (\$kernelopts)"`)

	selinuxGrubCfgRegex = regexp.MustCompile(`\tlinux .* (security=selinux selinux=1( enforcing=1)?) `)
	selinuxGrubRegex    = regexp.MustCompile(`GRUB_CMDLINE_LINUX=".* (security=selinux selinux=1( enforcing=1)?) `)

	selinuxInsertGrubCfgRegex = regexp.MustCompile(`\tlinux \$bootprefix/\$mariner_linux `)
	selinuxInsertGrubRegex    = regexp.MustCompile(`GRUB_CMDLINE_LINUX="`)

	// Finds the SELinux mode line in the /etc/selinux/config file.
	selinuxConfigModeRegex = regexp.MustCompile(`(?m)^SELINUX=(\w+)$`)

	grub2MkconfigCommentRegex = regexp.MustCompile(`automatically generated by grub2-mkconfig`)
)

const (
	// The start index of "$kernelopts".
	// Note: regexp returns index pairs. So, "2" is the start index of the 1st group.
	linuxCommandLineRegexKernelOptsStart = 2

	// The start/end indexes of the SELinux args.
	// Note: regexp returns index pairs. So, "2" and "3" are the start and end indexes respectively of the 1st
	// group.
	linuxCommandLineSELinuxRegexSELinuxArgsStart = 2
	linuxCommandLineSELinuxRegexSELinuxArgsEnd   = 3

	// The start index of the "enforcing=1" arg.
	// Note: regexp returns index pairs. So, "4" is start index of the 2nd group.
	linuxCommandLineSELinuxRegexEnforcingStart = 4

	// The index of the SELinux mode value.
	selinuxConfigModeRegexSELinuxMode = 1
)

func handleKernelCommandLine(extraCommandLine string, grubMkConfigEnabled bool, imageChroot *safechroot.Chroot,
	partitionsCustomized bool,
) error {
	if partitionsCustomized {
		// ExtraCommandLine was handled when the new image was created and the grub.cfg file was regenerated from
		// scatch.
		return nil
	}

	if extraCommandLine == "" {
		// Nothing to do.
		return nil
	}

	logger.Log.Infof("Setting KernelCommandLine.ExtraCommandLine")

	// Don't update grub.cfg if it was auto-generated.
	if !grubMkConfigEnabled {
		err := handleKernelCommandLineHelper(extraCommandLine, installutils.GrubCfgFile, extraCommandLineInsertGrubCfgRegex,
			false /*allowFileMissing*/, imageChroot)
		if err != nil {
			return err
		}
	}

	err := handleKernelCommandLineHelper(extraCommandLine, installutils.GrubDefFile, extraCommandLineInsertGrubRegex,
		!grubMkConfigEnabled /*allowFileMissing*/, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

func handleKernelCommandLineHelper(extraCommandLine string, grubConfigFilePath string, insertRegexp *regexp.Regexp,
	allowMissingFile bool, imageChroot *safechroot.Chroot,
) error {
	grubConfigFullFilePath := filepath.Join(imageChroot.RootDir(), grubConfigFilePath)

	grub2ConfigFile, err := file.Read(grubConfigFullFilePath)
	if err != nil {
		if allowMissingFile {
			if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOENT {
				// Ignore 'no such file' error.
				return nil
			}
		}

		return fmt.Errorf("failed to read grub file (%s):\n%w", grubConfigFilePath, err)
	}

	// Find the point where the new command line arguments should be added.
	match := insertRegexp.FindStringSubmatchIndex(grub2ConfigFile)
	if match == nil {
		return fmt.Errorf("failed to find Linux kernel command line params in grub2 config file")
	}

	// Get the location of "$kernelopts".
	insertIndex := match[linuxCommandLineRegexKernelOptsStart]

	// Insert new command line arguments.
	newGrub2ConfigFile := grub2ConfigFile[:insertIndex] + extraCommandLine + " " + grub2ConfigFile[insertIndex:]

	// Update grub.cfg file.
	err = file.Write(newGrub2ConfigFile, grubConfigFullFilePath)
	if err != nil {
		return fmt.Errorf("failed to write grub file (%s):\n%w", grubConfigFilePath, err)
	}

	return nil
}

// Updates the kernel command-line args with the new SELinux mode.
//
// See, installutils.setGrubCfgSELinux()
func updateSELinuxCommandLine(selinuxMode imagecustomizerapi.SELinux, grubMkConfigEnabled bool,
	imageChroot *safechroot.Chroot,
) error {
	logger.Log.Infof("Updating SELinux kernel command-line args")

	// Don't update grub.cfg if it was auto-generated.
	if !grubMkConfigEnabled {
		err := updateSELinuxCommandLineHelper(selinuxMode, installutils.GrubCfgFile, selinuxGrubCfgRegex,
			selinuxInsertGrubCfgRegex, false /*allowFileMissing*/, imageChroot)
		if err != nil {
			return err
		}
	}

	err := updateSELinuxCommandLineHelper(selinuxMode, installutils.GrubDefFile, selinuxGrubRegex,
		selinuxInsertGrubRegex, !grubMkConfigEnabled /*allowFileMissing*/, imageChroot)
	if err != nil {
		return err
	}

	return nil
}

func updateSELinuxCommandLineHelper(selinuxMode imagecustomizerapi.SELinux, grubConfigFilePath string,
	findRegex *regexp.Regexp, insertRegexp *regexp.Regexp, allowMissingFile bool, imageChroot *safechroot.Chroot,
) error {
	grubConfigFullFilePath := filepath.Join(imageChroot.RootDir(), grubConfigFilePath)

	grub2Config, err := file.Read(grubConfigFullFilePath)
	if err != nil {
		if allowMissingFile {
			if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOENT {
				// Ignore 'no such file' error.
				return nil
			}
		}

		return fmt.Errorf("failed to read grub file (%s):\n%w", grubConfigFilePath, err)
	}

	// Try to find any existing SELinux args.
	selinuxArgsMatch := findRegex.FindStringSubmatchIndex(grub2Config)

	start := 0
	end := 0

	extraSpace := ""
	if selinuxArgsMatch == nil {
		// SELinux args are not in the grub.cfg file.
		if selinuxMode == imagecustomizerapi.SELinuxDisabled {
			// Nothing to do.
			return nil
		}

		insertLocationMatch := insertRegexp.FindStringIndex(grub2Config)
		if insertLocationMatch == nil {
			return fmt.Errorf("failed to find location to insert SELinux kernel command-line args")
		}

		// Use the end of the regex match as the point to do the insert at.
		start = insertLocationMatch[1]
		end = start

		// Ensure there is a space character after the new args.
		extraSpace = " "
	} else {
		// Get the range of the existing SELinux args, so that they can be replaced with the new SELinux args.

		start = selinuxArgsMatch[linuxCommandLineSELinuxRegexSELinuxArgsStart]
		end = selinuxArgsMatch[linuxCommandLineSELinuxRegexSELinuxArgsEnd]
	}

	newSELinuxArgs := ""
	switch selinuxMode {
	case imagecustomizerapi.SELinuxForceEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxForceEnforcing + extraSpace

	case imagecustomizerapi.SELinuxPermissive, imagecustomizerapi.SELinuxEnforcing:
		newSELinuxArgs = installutils.CmdlineSELinuxSettings + extraSpace

	case imagecustomizerapi.SELinuxDisabled:
		newSELinuxArgs = ""

	default:
		return fmt.Errorf("unknown SELinux mode (%s)", selinuxMode)
	}

	// Insert/replace/delete SELinux command-line arguments.
	newGrub2Config := grub2Config[:start] + newSELinuxArgs + grub2Config[end:]

	// Update grub.cfg file.
	err = file.Write(newGrub2Config, grubConfigFullFilePath)
	if err != nil {
		return fmt.Errorf("failed to write grub file (%s):\n%w", grubConfigFilePath, err)
	}

	return nil
}

func getCurrentSELinuxMode(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinux, error) {
	logger.Log.Debugf("Get existing SELinux mode")

	grubConfigFullFilePath := filepath.Join(imageChroot.RootDir(), installutils.GrubCfgFile)

	grub2Config, err := file.Read(grubConfigFullFilePath)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("failed to read grub.cfg file:\n%w", err)
	}

	// Try to find any existing SELinux args.
	selinuxArgsMatch := selinuxGrubCfgRegex.FindStringSubmatchIndex(grub2Config)
	if selinuxArgsMatch == nil {
		// SELinux not present in the kernel command-line.
		// Therefore, it is disabled.
		return imagecustomizerapi.SELinuxDisabled, nil
	}

	// Check if "enforcing=1" is present.
	// Note: A negative index means an optional sub-match is not present.
	if selinuxArgsMatch[linuxCommandLineSELinuxRegexEnforcingStart] >= 0 {
		return imagecustomizerapi.SELinuxForceEnforcing, nil
	}

	selinuxMode, err := getSELinuxModeFromConfigFile(imageChroot)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, err
	}

	return selinuxMode, nil
}

func getSELinuxModeFromConfigFile(imageChroot *safechroot.Chroot) (imagecustomizerapi.SELinux, error) {
	selinuxConfigFilePath := filepath.Join(imageChroot.RootDir(), installutils.SELinuxConfigFile)

	// Read the SELinux config file.
	selinuxConfig, err := file.Read(selinuxConfigFilePath)
	if err != nil {
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("failed to read SELinux config file (%s):\n%w",
			installutils.SELinuxConfigFile, err)
	}

	match := selinuxConfigModeRegex.FindStringSubmatch(selinuxConfig)
	if match == nil {
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("failed to find SELinux mode in (%s) file",
			installutils.SELinuxConfigFile)
	}

	selinuxConfigMode := match[selinuxConfigModeRegexSELinuxMode]

	switch selinuxConfigMode {
	case installutils.SELinuxConfigEnforcing:
		return imagecustomizerapi.SELinuxEnforcing, nil

	case installutils.SELinuxConfigPermissive:
		return imagecustomizerapi.SELinuxPermissive, nil

	case installutils.SELinuxConfigDisabled:
		return imagecustomizerapi.SELinuxDisabled, nil

	default:
		return imagecustomizerapi.SELinuxDefault, fmt.Errorf("unknown SELinux mode (%s) found in (%s) file",
			selinuxConfigMode, installutils.SELinuxConfigFile)
	}
}

// Checks if the image's grub.cfg file was generated by grub-mkconfig.
func isGrubMkconfigImage(imageChroot *safechroot.Chroot) (bool, error) {
	grubMkConfigEnabled, err := isGrubMkconfigImageHelper(imageChroot)
	if err != nil {
		return false, fmt.Errorf("failed to check if grub.cfg was generated by grub2-mkconfig:\n%w", err)
	}

	return grubMkConfigEnabled, nil
}

func isGrubMkconfigImageHelper(imageChroot *safechroot.Chroot) (bool, error) {
	logger.Log.Debugf("Check if grub.cfg was generated by grub-mkconfig")

	grubConfigFullFilePath := filepath.Join(imageChroot.RootDir(), installutils.GrubCfgFile)

	grub2Config, err := file.Read(grubConfigFullFilePath)
	if err != nil {
		return false, fmt.Errorf("failed to read grub.cfg file (%s):\n%w", installutils.GrubCfgFile, err)
	}

	match := grub2MkconfigCommentRegex.MatchString(grub2Config)
	return match, nil
}
